package tiedstate

import (
	"bufio"
	"encoding/binary"
	"fmt"
	"io"
	"math"
	"os"
	"path/filepath"
	"strings"

	"github.com/jtejido/go-sphinx/linguist/acoustic"
	"github.com/jtejido/go-sphinx/util"
)

const (
	CONTEXT_SIZE           = 1
	MODEL_VERSION          = "0.3"
	FILLER                 = "filler"
	SILENCE_CIPHONE        = "SIL"
	BYTE_ORDER_MAGIC       = 0x11223344
	DENSITY_FILE_VERSION   = "1.0"
	MIXW_FILE_VERSION      = "1.0"
	TMAT_FILE_VERSION      = "1.0"
	TRANSFORM_FILE_VERSION = "0.1"
)

const (
	DefaultMixtureComponentScoreFloor float32 = 0.0
	DefaultVarianceFloor              float32 = 0.0001
	DefaultMixtureWeightFloor         float32 = 1e-7
	DefaultTopGaussiansNum            int     = 4
)

/**
 * Loads a tied-state acoustic model generated by the Sphinx-3 trainer.
 * <p>
 * The acoustic model is stored as a directory specified by a URL. The
 * dictionary and language model files are not required to be in the package.
 * You can specify their locations separately.
 * <p>
 * Configuration file should set mandatory property of component: <b>location</b> -
 * this specifies the directory where the actual model
 * data files are. You can use <b>resource:</b> prefix to refer to files packed
 * inside jar or any other URI scheme.
 * The actual model data files are named "mdef", "means", "variances",
 * "transition_matrices", "mixture_weights".
 */

type Sphinx3Loader struct {
	modelProps                                           map[string]string
	meansPool                                            *Pool[[]float32]
	variancePool                                         *Pool[[]float32]
	transitionsPool                                      *Pool[[][]float32]
	mixtureWeights                                       *GaussianWeights
	numStates, numStreams, numBase, numGaussiansPerState int
	vectorLength, senone2ci                              []int
	meanTransformationMatrixPool                         *Pool[[][]float32]
	meanTransformationVectorPool                         *Pool[[]float32]
	varianceTransformationMatrixPool                     *Pool[[][]float32]
	varianceTransformationVectorPool                     *Pool[[]float32]
	transformMatrix                                      [][]float32
	phoneticTiedMixtures                                 []*tiedmixture.MixtureComponentSet
	senonePool                                           *Pool[Senone]
	contextIndependentUnits                              map[string]*acoustic.Unit
	hmmManager                                           *HMMManager
	logMath                                              *util.LogMath
	unitManager                                          *acoustic.UnitManager
	swap                                                 bool
	logger                                               util.Logger
	distFloor, mixtureWeightFloor, varianceFloor         float32
	topGauNum                                            int
	useCDUnits, loaded                                   bool
	location                                             string
	calculatedCheckSum                                   int64
}

func NewSphinx3Loader(location string,
	unitManager *acoustic.UnitManager, distFloor, mixtureWeightFloor,
	varianceFloor float32, topGauNum int, useCDUnits bool, logger util.Logger) *Sphinx3Loader {
	return &Sphinx3Loader{
		location:           location,
		logMath:            util.GetLogMath(),
		logger:             logger,
		unitManager:        unitManager,
		distFloor:          distFloor,
		mixtureWeightFloor: mixtureWeightFloor,
		varianceFloor:      varianceFloor,
		topGauNum:          topGauNum,
		useCDUnits:         useCDUnits,
	}
}

func (l *Sphinx3Loader) NumStates() int {
	return l.numStates
}

func (l *Sphinx3Loader) NumStreams() int {
	return l.numStreams
}

func (l *Sphinx3Loader) NumGaussiansPerState() int {
	return l.numGaussiansPerState
}

func (l *Sphinx3Loader) VectorLength() []int {
	return l.vectorLength
}

func (l *Sphinx3Loader) Senone2Ci() []int {
	return l.senone2ci
}

func (l *Sphinx3Loader) Location() string {
	return l.location
}

func (l *Sphinx3Loader) HasTiedMixtures() bool {
	modelType := l.modelProps["-model"]
	if modelType == "" {
		modelType = "cont"
	}

	return strings.ToLower(modelType) == "ptm"
}

func (l *Sphinx3Loader) DataStream(path string) (*os.File, error) {
	path = filepath.Join(l.location, path)
	f, err := os.Open(path)
	if err != nil {
		return nil, err
	}
	return f, nil
}

func (l *Sphinx3Loader) Load() error {
	if !l.loaded {
		util.GetTimerPool().GetTimer(l, "Load AM").Start()

		l.hmmManager = NewHMMManager()
		l.contextIndependentUnits = make(map[string]*acoustic.Unit)

		// dummy pools for these elements
		l.meanTransformationMatrixPool = nil
		l.meanTransformationVectorPool = nil
		l.varianceTransformationMatrixPool = nil
		l.varianceTransformationVectorPool = nil
		l.transformMatrix = nil

		// do the actual acoustic model loading
		if err := l.loadModelFiles(); err != nil {
			return err
		}

		// done
		l.loaded = true
		util.GetTimerPool().GetTimer(l, "Load AM").Stop()
	}
	return nil
}

/**
 * Return the HmmManager.
 *
 * @return the hmmManager
 */
func (l *Sphinx3Loader) HmmManager() *HMMManager {
	return l.hmmManager
}

/**
 * Return the MatrixPool.
 *
 * @return the matrixPool
 */
func (l *Sphinx3Loader) MatrixPool() *Pool[[][]float32] {
	return l.transitionsPool
}

/**
 * Return the MixtureWeightsPool.
 *
 * @return the mixtureWeightsPool
 */
func (l *Sphinx3Loader) MixtureWeightsPool() *GaussianWeights {
	return l.mixtureWeights
}

/**
 * Loads the AcousticModel from a directory in the file system.
 * @throws IOException IO went wrong
 * @throws URISyntaxException uri was incorrectly specified
 */
func (l *Sphinx3Loader) loadModelFiles() (err error) {
	l.meansPool, err = l.loadDensityFile("means", -math.MaxFloat32)
	if err != nil {
		return
	}
	l.variancePool, err = l.loadDensityFile("variances", l.varianceFloor)
	if err != nil {
		return
	}
	l.mixtureWeights, err = l.loadMixtureWeights("mixture_weights", l.mixtureWeightFloor)
	if err != nil {
		return
	}
	l.transitionsPool, err = l.loadTransitionMatrices("transition_matrices")
	if err != nil {
		return
	}
	l.transformMatrix, err = l.loadTransformMatrix("feature_transform")
	if err != nil {
		return
	}
	l.modelProps, err = l.loadModelProps("feat.params")
	if err != nil {
		return
	}

	if l.HasTiedMixtures() {
		//create senone to CI mapping
		if err := l.senoneToCIPhone(); err != nil {
			return err
		}
		//create tied senone pool
		l.senonePool = l.createTiedSenonePool(l.distFloor, l.varianceFloor)
	} else {
		//create regular senone poll
		l.senonePool, err = l.createSenonePool(l.distFloor, l.varianceFloor)
		if err != nil {
			return
		}
	}

	// load the HMM modelDef file
	modelStream, err := l.DataStream("mdef")
	if err != nil {
		return err
	}
	if modelStream == nil {
		return fmt.Errorf("can't find model definition")
	}
	return l.loadHMMPool(l.useCDUnits, modelStream)
}

func (l *Sphinx3Loader) ContextIndependentUnits() map[string]*acoustic.Unit {
	return l.contextIndependentUnits
}

/**
 * Creates senone to CI phone mapping, reading model definition file
 */
func (l *Sphinx3Loader) senoneToCIPhone() (err error) {
	inputStream, err := l.DataStream("mdef")
	if err != nil {
		return err
	}
	if inputStream == nil {
		return fmt.Errorf("can't find model definition")
	}
	defer inputStream.Close()
	var est *util.ExtendedStreamTokenizer
	est, err = util.NewExtendedStreamTokenizerFromReader(inputStream, '#', false)
	if err != nil {
		return
	}

	l.logger.Finef("Loading HMM file from %s", l.location)

	if err = est.ExpectString(MODEL_VERSION); err != nil {
		return
	}

	l.numBase, err = est.GetInt("numBase")
	if err != nil {
		return
	}
	if err = est.ExpectString("n_base"); err != nil {
		return
	}

	var numTri, numStateMap, numTiedState, numTiedTransitionMatrices int
	numTri, err = est.GetInt("numTri")
	if err != nil {
		return
	}
	if err = est.ExpectString("n_tri"); err != nil {
		return
	}

	numStateMap, err = est.GetInt("numStateMap")
	if err != nil {
		return
	}
	if err = est.ExpectString("n_state_map"); err != nil {
		return
	}

	numTiedState, err = est.GetInt("numTiedState")
	if err != nil {
		return
	}
	if err = est.ExpectString("n_tied_state"); err != nil {
		return
	}

	l.senone2ci = make([]int, numTiedState)

	_, err = est.GetInt("numContextIndependentTiedState")
	if err != nil {
		return
	}
	if err = est.ExpectString("n_tied_ci_state"); err != nil {
		return
	}

	numTiedTransitionMatrices, err = est.GetInt("numTiedTransitionMatrices")
	if err != nil {
		return
	}
	if err = est.ExpectString("n_tied_tmat"); err != nil {
		return
	}

	numStatePerHMM := numStateMap / (numTri + l.numBase)

	assert(numTiedState == l.mixtureWeights.StatesNum())
	assert(numTiedTransitionMatrices == l.transitionsPool.Size())

	// Load the base phones
	var tmat int
	for i := 0; i < l.numBase+numTri; i++ {
		//TODO name this magic const somehow
		for j := 0; j < 5; j++ {
			if _, err = est.GetString(); err != nil {
				return
			}
		}
		tmat, err = est.GetInt("tmat")
		if err != nil {
			return
		}
		var ji int
		for j := 0; j < numStatePerHMM-1; j++ {
			ji, err = est.GetInt("j")
			if err != nil {
				return
			}
			l.senone2ci[ji] = tmat
		}
		if err = est.ExpectString("N"); err != nil {
			return
		}

		assert(tmat < numTiedTransitionMatrices)
	}

	return nil
}

/**
 * Creates the senone pool from the rest of the pools.
 *
 * @param distFloor
 *            the lowest allowed score
 * @param varianceFloor
 *            the lowest allowed variance
 * @return the senone pool
 */
func (l *Sphinx3Loader) createSenonePool(distFloor, varianceFloor float32) *Pool[Senone] {
	pool := NewPool[Senone]("senones")

	numMeans := l.meansPool.Size()
	numVariances := l.variancePool.Size()
	numGaussiansPerSenone := l.mixtureWeights.GauPerState()
	numSenones := l.mixtureWeights.StatesNum()
	numStreams := l.mixtureWeights.StreamsNum()
	var whichGaussian int

	l.logger.Finef("Senones %d", numSenones)
	l.logger.Finef("Gaussians Per Senone %d", numGaussiansPerSenone)
	l.logger.Finef("Means %d", numMeans)
	l.logger.Finef("Variances %d", numVariances)

	assert(numGaussiansPerSenone > 0)
	assert(numVariances == numSenones*numGaussiansPerSenone)
	assert(numMeans == numSenones*numGaussiansPerSenone)
	var meansTransformationMatrix, varianceTransformationMatrix [][]float32
	var meansTransformationVector, varianceTransformationVector []float32

	if l.meanTransformationMatrixPool != nil {
		meansTransformationMatrix = l.meanTransformationMatrixPool.Get(0)
	}

	if l.meanTransformationVectorPool != nil {
		meansTransformationVector = l.meanTransformationVectorPool.Get(0)
	}

	if l.varianceTransformationMatrixPool != nil {
		varianceTransformationMatrix = l.varianceTransformationMatrixPool.Get(0)
	}

	if l.varianceTransformationVectorPool != nil {
		varianceTransformationVector = l.varianceTransformationVectorPool.Get(0)
	}

	for i := 0; i < numSenones; i++ {
		mixtureComponents := make([]*MixtureComponent, numGaussiansPerSenone*numStreams)
		for j := 0; j < numGaussiansPerSenone; j++ {
			mixtureComponents[j] = NewMixtureComponent(
				l.meansPool.Get(whichGaussian),
				meansTransformationMatrix, meansTransformationVector,
				l.variancePool.Get(whichGaussian),
				varianceTransformationMatrix,
				varianceTransformationVector, distFloor, varianceFloor)

			whichGaussian++
		}

		senone := newGaussianMixture(mixtureWeights, mixtureComponents, i)
		pool.Put(i, senone)
	}
	return pool
}

/**
 * Loads the sphinx3 density file, a set of density arrays are created and
 * placed in the given pool.
 *
 * @param path
 *            the name of the data
 * @param floor
 *            the minimum density allowed
 * @return a pool of loaded densities
 * @throws FileNotFoundException
 *             if a file cannot be found
 * @throws IOException
 *             if an error occurs while loading the data
 * @throws URISyntaxException uri was incorrectly specified
 */
func (l *Sphinx3Loader) loadDensityFile(path string, floor float32) (*Pool[[]float32], error) {
	props := make(map[string]string)
	var blockSize int

	dis, err := l.ReadS3BinaryHeader(path, props)
	if err != nil {
		return nil, err
	}

	version, vok := props["version"]

	if !vok || version != DENSITY_FILE_VERSION {
		return nil, fmt.Errorf("Unsupported version in %s", path)
	}

	checksum, cok := props["chksum0"]
	doCheckSum := (cok && checksum == "yes")
	l.resetChecksum()

	numStates, err := l.ReadInt(dis)
	if err != nil {
		return nil, err
	}

	numStreams, err := l.ReadInt(dis)
	if err != nil {
		return nil, err
	}

	numGaussiansPerState, err := l.ReadInt(dis)
	if err != nil {
		return nil, err
	}

	vectorLength := make([]int, numStreams)

	for i := 0; i < numStreams; i++ {
		var err error
		vectorLength[i], err = l.ReadInt(dis)
		if err != nil {
			return nil, err
		}
	}

	rawLength, err := l.ReadInt(dis)
	if err != nil {
		return nil, err
	}

	l.logger.Finef("Number of states %d", numStates)
	l.logger.Finef("Number of streams %d", numStreams)
	l.logger.Finef("Number of gaussians per state %d", numGaussiansPerState)
	l.logger.Finef("Vector length %d", len(vectorLength))
	l.logger.Finef("Raw length %d", rawLength)

	for i := 0; i < numStreams; i++ {
		blockSize += vectorLength[i]
	}

	assert(rawLength == numGaussiansPerState*blockSize*numStates)

	pool := NewPool[[]float32](path)
	pool.SetFeature(NUM_SENONES, numStates)
	pool.SetFeature(NUM_STREAMS, numStreams)
	pool.SetFeature(NUM_GAUSSIANS_PER_STATE, numGaussiansPerState)

	for i := 0; i < numStates; i++ {
		for j := 0; j < numStreams; j++ {
			for k := 0; k < numGaussiansPerState; k++ {
				density, err := l.ReadFloatArray(dis, vectorLength[j])
				if err != nil {
					return nil, err
				}
				util.FloorData(density, floor)
				pool.Put(i*numStreams*numGaussiansPerState+j*numGaussiansPerState+k, density)
			}
		}
	}

	if err := l.validateChecksum(dis, doCheckSum); err != nil {
		return nil, err
	}

	l.numStates = numStates
	l.numStreams = numStreams
	l.numGaussiansPerState = numGaussiansPerState
	l.vectorLength = vectorLength

	return pool, dis.Close()
}

func (l *Sphinx3Loader) ReadInt(dis io.Reader) (val int, err error) {
	if l.swap {
		// err := binary.Read(dis, binary.LittleEndian, &val)
		val, err = util.ReadLittleEndianInt(dis)
		if err != nil {
			return
		}
	} else {
		err = binary.Read(dis, binary.BigEndian, &val)
		if err != nil {
			return
		}
	}
	return
}

/**
 * Reads the given number of floats from the stream and returns them in an
 * array of floats.
 *
 * @param dis
 *            the stream to read data from
 * @param size
 *            the number of floats to read
 * @return an array of size float elements
 * @throws IOException
 *             if an exception occurs
 */
func (l *Sphinx3Loader) ReadFloatArray(dis io.Reader, size int) (data []float32, err error) {
	data = make([]float32, size)
	for i := 0; i < size; i++ {
		data[i], err = l.ReadFloat(dis)
		if err != nil {
			return
		}
	}
	return
}

/**
 * Read a float from the input stream, byte-swapping as necessary.
 *
 * @param dis
 *            the input stream
 * @return a floating pint value
 * @throws IOException
 *             on error
 */
func (l *Sphinx3Loader) ReadFloat(dis io.Reader) (val float32, err error) {
	var v int
	if l.swap {
		v, err = util.ReadLittleEndianInt(dis)
		if err != nil {
			return
		}
	} else {
		err = binary.Read(dis, binary.BigEndian, &v)
		if err != nil {
			return
		}
	}
	l.calculatedCheckSum = ((l.calculatedCheckSum<<20 | l.calculatedCheckSum>>12) + int64(v)) & 0xFFFFFFFF
	return intBitsToFloat(int32(v)), nil
}

func intBitsToFloat(bits int32) float32 {
	return math.Float32frombits(uint32(bits))
}

/**
 * Reads the S3 binary header from the given location + path. Adds header
 * information to the given set of properties.
 *
 * @param path
 *            the name of the file
 * @param props
 *            the properties
 * @return the input stream positioned after the header
 * @throws IOException
 *             on error
 * @throws URISyntaxException uri was incorrectly specified
 */
func (l *Sphinx3Loader) ReadS3BinaryHeader(path string, props map[string]string) (inputStream *os.File, err error) {
	inputStream, err = l.DataStream(path)
	if err != nil {
		return
	}

	if inputStream == nil {
		return nil, fmt.Errorf("Can't open %s.", path)
	}

	reader := bufio.NewReader(inputStream)

	id, err := readWord(reader)
	if err != nil {
		return nil, fmt.Errorf("error reading S3 binary header ID: %w", err)
	}
	if id != "s3" {
		return nil, fmt.Errorf("Not a proper s3 binary file %s.", path)
	}
	var name string
	for {
		name, err = readWord(reader)
		if err != nil {
			return nil, fmt.Errorf("error reading S3 header name: %w", err)
		}

		if name == "endhdr" {
			break
		}

		value, err := readWord(reader)
		if err != nil {
			return nil, fmt.Errorf("error reading S3 header value: %w", err)
		}

		props[name] = value
	}
	var byteOrderMagic int32
	err = binary.Read(reader, binary.BigEndian, &byteOrderMagic)
	if err != nil {
		return nil, fmt.Errorf("error reading byte order magic: %w", err)
	}

	if byteOrderMagic == BYTE_ORDER_MAGIC {
		l.logger.Finef("Not swapping %s", path)
		l.swap = false
	} else if util.SwapInteger(byteOrderMagic) == BYTE_ORDER_MAGIC {
		l.logger.Finef("Swapping  %s", path)
		l.swap = true
	} else {
		return nil, fmt.Errorf("Corrupted S3 file %s", path)
	}

	return
}

func (l *Sphinx3Loader) resetChecksum() {
	l.calculatedCheckSum = 0
}

/**
 * Validates checksum in the stream
 *
 * @param dis
 *            input stream
 * @param doCheckSum
 *            validates
 * @throws IOException
 *             on error
 **/
func (l *Sphinx3Loader) validateChecksum(dis io.Reader, doCheckSum bool) error {
	if !doCheckSum {
		return nil
	}
	oldCheckSum := int(l.calculatedCheckSum)
	checkSum, err := l.ReadInt(dis)
	if err != nil {
		return err
	}
	if checkSum != oldCheckSum {
		return fmt.Errorf("Invalid checksum %x must be %x", l.calculatedCheckSum, checkSum)
	}

	return nil
}

// readWord reads the next word (text separated by whitespace) from the given stream.
func readWord(dis *bufio.Reader) (string, error) {
	var sb []rune
	var c rune

	// skip leading whitespace
	for {
		char, _, err := dis.ReadRune()
		if err != nil {
			return "", err
		}
		if !isWhitespace(char) {
			c = char
			break
		}
	}

	// read the word
	for {
		sb = append(sb, c)
		char, _, err := dis.ReadRune()
		if err != nil {
			if err == io.EOF {
				break
			}
			return "", err
		}
		if isWhitespace(char) {
			break
		}
		c = char
	}

	return string(sb), nil
}

// isWhitespace checks if the rune is a whitespace character.
func isWhitespace(c rune) bool {
	return c == ' ' || c == '\t' || c == '\n' || c == '\r'
}

/**
 * Loads the mixture weights (Binary).
 *
 * @param path
 *            the path to the mixture weight file
 * @param floor
 *            the minimum mixture weight allowed
 * @return a pool of mixture weights
 * @throws IOException
 *             if an error occurs while loading the data
 * @throws URISyntaxException uri was incorrectly specified
 */
func (l *Sphinx3Loader) loadMixtureWeights(path string, floor float32) (*GaussianWeights, error) {
	l.logger.Finef("Loading mixture weights from: %s", path)

	props := make(map[string]string)

	dis, err := l.ReadS3BinaryHeader(path, props)
	if err != nil {
		return nil, err
	}

	version, vok := props["version"]
	if !vok || version != MIXW_FILE_VERSION {
		return nil, fmt.Errorf("Unsupported version in %s", path)
	}

	checksum, cok := props["chksum0"]
	doCheckSum := (cok && checksum == "yes")
	l.resetChecksum()

	numStates, err := l.ReadInt(dis)
	if err != nil {
		return nil, err
	}

	numStreams, err := l.ReadInt(dis)
	if err != nil {
		return nil, err
	}

	numGaussiansPerState, err := l.ReadInt(dis)
	if err != nil {
		return nil, err
	}

	numValues, err := l.ReadInt(dis)
	if err != nil {
		return nil, err
	}
	mixtureWeights := NewGaussianWeights(path, numStates, numGaussiansPerState, numStreams)

	l.logger.Finef("Number of states %d", numStates)
	l.logger.Finef("Number of streams %d", numStreams)
	l.logger.Finef("Number of gaussians per state %d", numGaussiansPerState)

	assert(numValues == numStates*numStreams*numGaussiansPerState)

	for i := 0; i < numStates; i++ {
		for j := 0; j < numStreams; j++ {
			logStreamMixtureWeight, err := l.ReadFloatArray(dis, numGaussiansPerState)
			if err != nil {
				return nil, err
			}
			util.Normalize(logStreamMixtureWeight)
			util.FloorData(logStreamMixtureWeight, floor)
			util.GetLogMath().LinearToLogFromFloats(logStreamMixtureWeight)
			mixtureWeights.Put(i, j, logStreamMixtureWeight)
		}
	}

	if err := l.validateChecksum(dis, doCheckSum); err != nil {
		return nil, err
	}

	return mixtureWeights, dis.Close()
}

/**
 * Loads the transition matrices (Binary).
 *
 * @param path
 *            the path to the transitions matrices
 * @return a pool of transition matrices
 * @throws IOException
 *             if an error occurs while loading the data
 * @throws URISyntaxException uri was incorrectly specified
 */
func (l *Sphinx3Loader) loadTransitionMatrices(path string) (*Pool[[][]float32], error) {
	l.logger.Finef("Loading transition matrices from: " + path)

	props := make(map[string]string)
	dis, err := l.ReadS3BinaryHeader(path, props)
	if err != nil {
		return nil, err
	}

	version, vok := props["version"]
	if !vok || version != TMAT_FILE_VERSION {
		return nil, fmt.Errorf("Unsupported version in %s", path)
	}

	checksum, cok := props["chksum0"]
	doCheckSum := (cok && checksum == "yes")
	l.resetChecksum()

	pool := NewPool[[][]float32](path)

	numMatrices, err := l.ReadInt(dis)
	if err != nil {
		return nil, err
	}

	numRows, err := l.ReadInt(dis)
	if err != nil {
		return nil, err
	}

	numStates, err := l.ReadInt(dis)
	if err != nil {
		return nil, err
	}

	numValues, err := l.ReadInt(dis)
	if err != nil {
		return nil, err
	}

	assert(numValues == numStates*numRows*numMatrices)

	for i := 0; i < numMatrices; i++ {
		tmat := make([][]float32, numStates)
		// last row should be zeros
		tmat[numStates-1] = make([]float32, numStates)
		util.GetLogMath().LinearToLogFromFloats(tmat[numStates-1])

		var err error
		for j := 0; j < numRows; j++ {
			tmat[j], err = l.ReadFloatArray(dis, numStates)
			if err != nil {
				return nil, err
			}
			util.NonZeroFloor(tmat[j], 0)
			util.Normalize(tmat[j])
			util.GetLogMath().LinearToLogFromFloats(tmat[j])
		}
		pool.Put(i, tmat)
	}

	if err := l.validateChecksum(dis, doCheckSum); err != nil {
		return nil, err
	}

	return pool, dis.Close()
}

/**
 * Loads the transform matrices (Binary).
 *
 * @param path
 *            the path to the transform matrix
 * @return a transform matrix
 * @throws java.io.FileNotFoundException
 *             if a file cannot be found
 * @throws java.io.IOException
 *             if an error occurs while loading the data
 */
func (l *Sphinx3Loader) loadTransformMatrix(path string) ([][]float32, error) {
	l.logger.Finef("Loading transform matrix from: %s", path)

	props := make(map[string]string)

	dis, err := l.ReadS3BinaryHeader(path, props)
	if err != nil {
		return nil, err
	}

	version, vok := props["version"]
	if !vok || version != TRANSFORM_FILE_VERSION {
		return nil, fmt.Errorf("Unsupported version in %s", path)
	}

	checksum, cok := props["chksum0"]
	doCheckSum := (cok && checksum == "yes")
	l.resetChecksum()

	_, err = l.ReadInt(dis)
	if err != nil {
		return nil, err
	}
	numRows, err := l.ReadInt(dis)
	if err != nil {
		return nil, err
	}
	numValues, err := l.ReadInt(dis)
	if err != nil {
		return nil, err
	}
	num, err := l.ReadInt(dis)
	if err != nil {
		return nil, err
	}

	assert(num == numRows*numValues)

	result := make([][]float32, numRows)
	for i := 0; i < numRows; i++ {
		result[i], err = l.ReadFloatArray(dis, numValues)
	}

	if err := l.validateChecksum(dis, doCheckSum); err != nil {
		return nil, err
	}

	return result, dis.Close()
}

func (l *Sphinx3Loader) loadModelProps(path string) (map[string]string, error) {
	props := make(map[string]string)
	stream, err := l.DataStream(path)
	if err != nil {
		return nil, err
	}

	reader := bufio.NewReader(stream)
	for {
		line, err := reader.ReadString('\n')
		if err == nil || len(line) > 0 {
			tokens := strings.Fields(line)
			if len(tokens) >= 2 {
				props[tokens[0]] = tokens[1]
			}
		} else {
			break
		}
	}

	return props, nil
}
